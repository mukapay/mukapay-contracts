const { expect } = require("chai");
const { ethers } = require("hardhat");
const { generateProof, getUsernameHash } = require("../src/utils");

describe("HashVerifier", function () {
  let vault;
  let verifier;
  let mockUSDC;
  let owner;
  let user;
  let user2;

  // Test credentials
  const testUsername = "alice";
  const testUsername2 = "bob";
  const testPassword = "password123";
  const testNonce = "1234567890";
  const depositAmount = ethers.parseUnits("100", 6); // 100 USDC
  const payAmount = ethers.parseUnits("50", 6); // 50 USDC

  beforeEach(async function () {
    // Get signers
    [owner, user, user2] = await ethers.getSigners();

    // Deploy MockUSDC
    const MockUSDC = await ethers.getContractFactory("MockUSDC");
    mockUSDC = await MockUSDC.deploy();
    await mockUSDC.waitForDeployment();

    // Deploy the Verifier contract first (this is the one generated by circom)
    const Verifier = await ethers.getContractFactory("Groth16Verifier");
    verifier = await Verifier.deploy();
    await verifier.waitForDeployment();

    // Deploy Vault with the Verifier address and MockUSDC address
    const Vault = await ethers.getContractFactory("Vault");
    vault = await Vault.deploy(await verifier.getAddress(), await mockUSDC.getAddress());
    await vault.waitForDeployment();

    // Mint some USDC to user
    await mockUSDC.mint(user.address, depositAmount);
    await mockUSDC.mint(user2.address, depositAmount);
  });

  describe("Deployment", function () {
    it("Should set the correct verifier and USDC addresses", async function () {
      expect(await vault.verifier()).to.equal(await verifier.getAddress());
      expect(await vault.usdc()).to.equal(await mockUSDC.getAddress());
    });
  });

  describe("Deposits and Payments", function () {
    let aliceProof, bobProof;
    let aliceUsernameHash, bobUsernameHash;

    beforeEach(async function () {
      // Generate proofs for both users (only needed for payment tests)
      // aliceProof = await generateProof(testUsername, testPassword, testNonce);
      // bobProof = await generateProof(testUsername2, testPassword, testNonce);

      // Store username hashes

      aliceUsernameHash = getUsernameHash(testUsername)
      bobUsernameHash = getUsernameHash(testUsername2)

      // // Format proof data for payment tests
      // const aliceFormatted = {
      //   pi_a: aliceProof.proof.pi_a,
      //   pi_b: aliceProof.proof.pi_b,
      //   pi_c: aliceProof.proof.pi_c
      // };
      // aliceProof = {
      //   ...aliceFormatted,
      //   publicSignals: aliceProof.publicSignals
      // };

      // Approve USDC spending
      await mockUSDC.connect(user).approve(vault.getAddress(), depositAmount);
      await mockUSDC.connect(user2).approve(vault.getAddress(), depositAmount);
    });

    it("Should allow depositing USDC", async function () {
      await expect(vault.connect(user).deposit(aliceUsernameHash, depositAmount))
        .to.emit(vault, "Deposited")
        .withArgs(aliceUsernameHash, depositAmount);

      expect(await vault.balances(aliceUsernameHash)).to.equal(depositAmount);
    });

    it("Should not allow depositing zero amount", async function () {
      await expect(
        vault.connect(user).deposit(aliceUsernameHash, 0)
      ).to.be.revertedWith("Amount must be greater than 0");
    });

    it("Should not allow depositing to zero username hash", async function () {
      await expect(
        vault.connect(user).deposit(0, depositAmount)
      ).to.be.revertedWith("Invalid username hash");
    });

    it("Should fail deposit if USDC transfer fails", async function () {
      // Remove approval
      await mockUSDC.connect(user).approve(vault.getAddress(), 0);
      
      await expect(
        vault.connect(user).deposit(aliceUsernameHash, depositAmount)
      ).to.be.reverted; // OpenZeppelin IERC20 uses custom errors
    });

    it("Should allow paying USDC between users", async function () {
      // First deposit
      await vault.connect(user).deposit(aliceUsernameHash, depositAmount);

      // Generate new proof for payment (need new nonce)
      const paymentProof = await generateProof(testUsername, testPassword, "9876543210");
      const paymentFormatted = {
        pi_a: paymentProof.proof.pi_a.slice(0, 2),
        pi_b: [
          [paymentProof.proof.pi_b[0][1], paymentProof.proof.pi_b[0][0]],
          [paymentProof.proof.pi_b[1][1], paymentProof.proof.pi_b[1][0]]
        ],
        pi_c: paymentProof.proof.pi_c.slice(0, 2)
      };

      // Then pay
      await expect(
        vault.connect(user).pay(
          paymentFormatted.pi_a,
          paymentFormatted.pi_b,
          paymentFormatted.pi_c,
          aliceUsernameHash,
          bobUsernameHash,
          paymentProof.publicSignals[1],
          paymentProof.publicSignals[2],
          payAmount
        )
      )
        .to.emit(vault, "Paid")
        .withArgs(aliceUsernameHash, bobUsernameHash, payAmount);

      expect(await vault.balances(aliceUsernameHash)).to.equal(depositAmount - payAmount);
      expect(await vault.balances(bobUsernameHash)).to.equal(payAmount);
    });

    it("Should not allow payment without sufficient balance", async function () {
      const paymentProof = await generateProof(testUsername, testPassword, "9876543210");
      const paymentFormatted = {
        pi_a: paymentProof.proof.pi_a.slice(0, 2),
        pi_b: [
          [paymentProof.proof.pi_b[0][1], paymentProof.proof.pi_b[0][0]],
          [paymentProof.proof.pi_b[1][1], paymentProof.proof.pi_b[1][0]]
        ],
        pi_c: paymentProof.proof.pi_c.slice(0, 2)
      };

      await expect(
        vault.connect(user).pay(
          paymentFormatted.pi_a,
          paymentFormatted.pi_b,
          paymentFormatted.pi_c,
          aliceUsernameHash,
          bobUsernameHash,
          paymentProof.publicSignals[1],
          paymentProof.publicSignals[2],
          payAmount
        )
      ).to.be.revertedWith("Insufficient balance");
    });

    it("Should not allow using the same nonce twice", async function () {
      // First deposit
      await vault.connect(user).deposit(aliceUsernameHash, depositAmount);

      // Generate payment proof
      const paymentProof = await generateProof(testUsername, testPassword, testNonce);
      const paymentFormatted = {
        pi_a: paymentProof.proof.pi_a.slice(0, 2),
        pi_b: [
          [paymentProof.proof.pi_b[0][1], paymentProof.proof.pi_b[0][0]],
          [paymentProof.proof.pi_b[1][1], paymentProof.proof.pi_b[1][0]]
        ],
        pi_c: paymentProof.proof.pi_c.slice(0, 2)
      };

      // First payment succeeds
      await vault.connect(user).pay(
        paymentFormatted.pi_a,
        paymentFormatted.pi_b,
        paymentFormatted.pi_c,
        aliceUsernameHash,
        bobUsernameHash,
        paymentProof.publicSignals[1],
        paymentProof.publicSignals[2],
        payAmount
      );

      // Second payment with same nonce fails
      await expect(
        vault.connect(user).pay(
          paymentFormatted.pi_a,
          paymentFormatted.pi_b,
          paymentFormatted.pi_c,
          aliceUsernameHash,
          bobUsernameHash,
          paymentProof.publicSignals[1],
          paymentProof.publicSignals[2],
          payAmount
        )
      ).to.be.revertedWith("Nonce already used");
    });
  });
}); 