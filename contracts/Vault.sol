// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract Vault {
    // Mapping to track used nonces for each username hash
    mapping(uint256 => mapping(uint256 => bool)) public usedNonces;
    
    // Mapping to store balances for each username hash
    mapping(uint256 => uint256) public balances;

    // Mapping to store credential hashes for each username hash
    mapping(uint256 => uint256) public credentialHashes;
    
    // The Verifier contract will be generated by snarkjs/circom
    IVerifier public verifier;
    
    // USDC token contract
    IERC20 public immutable usdc;
    
    event Deposited(uint256 indexed usernameHash, uint256 amount);
    event Paid(uint256 indexed fromUsernameHash, uint256 indexed toUsernameHash, uint256 amount);
    event Withdrawn(uint256 indexed fromUsernameHash, address indexed toUserAddress, uint256 amount);
    event Registered(uint256 indexed usernameHash, uint256 credentialHash);
    
    constructor(address _verifierAddress, address _usdcAddress) {
        verifier = IVerifier(_verifierAddress);
        usdc = IERC20(_usdcAddress);
    }

    // Register a new user with their credential hash
    function register(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256 usernameHash,
        uint256 credentialHash,
        uint256 nonce,
        uint256 resultHash
    ) external {
        require(usernameHash != 0, "Invalid username hash");
        require(credentialHash != 0, "Invalid credential hash");
        require(credentialHashes[usernameHash] == 0, "Username already registered");
        require(!usedNonces[usernameHash][nonce], "Nonce already used");

        // Verify the proof that the user knows the username and password
        uint256[4] memory publicInputs;
        publicInputs[0] = usernameHash;
        publicInputs[1] = credentialHash;
        publicInputs[2] = nonce;
        publicInputs[3] = resultHash;
        
        require(verifier.verifyProof(a, b, c, publicInputs), "Invalid proof");
        
        // Mark nonce as used
        usedNonces[usernameHash][nonce] = true;
        
        // Store the credential hash
        credentialHashes[usernameHash] = credentialHash;
        
        emit Registered(usernameHash, credentialHash);
    }
    
    // Verify ownership using ZK proof
    function verify(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256 usernameHash,
        uint256 credentialHash,
        uint256 nonce,
        uint256 resultHash
    ) internal returns (bool) {
        require(!usedNonces[usernameHash][nonce], "Nonce already used");
        require(credentialHashes[usernameHash] == credentialHash, "Invalid credentials");
        
        // Verify the proof
        uint256[4] memory publicInputs;
        publicInputs[0] = usernameHash;
        publicInputs[1] = credentialHash;
        publicInputs[2] = nonce;
        publicInputs[3] = resultHash;
        
        require(verifier.verifyProof(a, b, c, publicInputs), "Invalid proof");
        
        // Mark nonce as used
        usedNonces[usernameHash][nonce] = true;
        
        return true;
    }

    // Deposit USDC tokens to a username hash
    function deposit(
        uint256 usernameHash,
        uint256 amount
    ) external {
        require(amount > 0, "Amount must be greater than 0");
        require(usernameHash != 0, "Invalid username hash");
        
        // Transfer USDC from sender to contract
        require(usdc.transferFrom(msg.sender, address(this), amount), "Transfer failed");
        
        // Update balance
        balances[usernameHash] += amount;
        
        emit Deposited(usernameHash, amount);
    }

    // Pay USDC tokens from one username hash to another
    function pay(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256 fromUsernameHash,
        uint256 toUsernameHash,
        uint256 credentialHash,
        uint256 nonce,
        uint256 resultHash,
        uint256 amount
    ) external returns (bool) {
        require(toUsernameHash != 0, "Invalid recipient");
        
        // Verify ownership of the sending account
        require(verify(a, b, c, fromUsernameHash, credentialHash, nonce, resultHash), "Verification failed");
        
        // Check sufficient balance
        require(balances[fromUsernameHash] >= amount, "Insufficient balance");
        
        // Update balances
        balances[fromUsernameHash] -= amount;
        balances[toUsernameHash] += amount;
        
        emit Paid(fromUsernameHash, toUsernameHash, amount);
        return true;
    }

    function withdraw(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256 fromUsernameHash,
        address toUserAddress,
        uint256 credentialHash,
        uint256 nonce,
        uint256 resultHash,
        uint256 amount
    ) external returns (bool) {
        require(credentialHashes[fromUsernameHash] != 0, "Sender not registered");
        
        // Verify ownership of the sending account
        require(verify(a, b, c, fromUsernameHash, credentialHash, nonce, resultHash), "Verification failed");
        
        // Check sufficient balance
        require(balances[fromUsernameHash] >= amount, "Insufficient balance");
        
        // Update balances
        balances[fromUsernameHash] -= amount;

        // Transfer USDC from contract to user
        require(usdc.transfer(toUserAddress, amount), "Transfer failed");

        emit Withdrawn(fromUsernameHash, toUserAddress, amount);
        return true;
    }
}

interface IVerifier {
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[4] memory input
    ) external view returns (bool);
} 