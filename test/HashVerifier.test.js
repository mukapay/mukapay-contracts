const { expect } = require("chai");
const { ethers } = require("hardhat");
const { generateProof } = require("../src/utils");

describe("HashVerifier", function () {
  let hashVerifier;
  let verifier;
  let mockUSDC;
  let owner;
  let user;
  let user2;

  // Test credentials
  const testUsername = "alice";
  const testUsername2 = "bob";
  const testPassword = "password123";
  const testNonce = "1234567890";
  const depositAmount = ethers.parseUnits("100", 6); // 100 USDC
  const payAmount = ethers.parseUnits("50", 6); // 50 USDC

  beforeEach(async function () {
    // Get signers
    [owner, user, user2] = await ethers.getSigners();

    // Deploy MockUSDC
    const MockUSDC = await ethers.getContractFactory("MockUSDC");
    mockUSDC = await MockUSDC.deploy();
    await mockUSDC.waitForDeployment();

    // Deploy the Verifier contract first (this is the one generated by circom)
    const Verifier = await ethers.getContractFactory("Groth16Verifier");
    verifier = await Verifier.deploy();
    await verifier.waitForDeployment();

    // Deploy HashVerifier with the Verifier address and MockUSDC address
    const HashVerifier = await ethers.getContractFactory("HashVerifier");
    hashVerifier = await HashVerifier.deploy(await verifier.getAddress(), await mockUSDC.getAddress());
    await hashVerifier.waitForDeployment();

    // Mint some USDC to user
    await mockUSDC.mint(user.address, depositAmount);
    await mockUSDC.mint(user2.address, depositAmount);
  });

  describe("Deployment", function () {
    it("Should set the correct verifier and USDC addresses", async function () {
      expect(await hashVerifier.verifier()).to.equal(await verifier.getAddress());
      expect(await hashVerifier.usdc()).to.equal(await mockUSDC.getAddress());
    });
  });

  describe("Deposits and Payments", function () {
    let aliceProof, bobProof;
    let aliceUsernameHash, bobUsernameHash;

    beforeEach(async function () {
      // Generate proofs for both users (only needed for payment tests)
      aliceProof = await generateProof(testUsername, testPassword, testNonce);
      bobProof = await generateProof(testUsername2, testPassword, testNonce);

      // Store username hashes
      aliceUsernameHash = aliceProof.publicSignals[0];
      bobUsernameHash = bobProof.publicSignals[0];

      // Format proof data for payment tests
      const aliceFormatted = {
        pi_a: aliceProof.proof.pi_a.slice(0, 2),
        pi_b: [
          [aliceProof.proof.pi_b[0][1], aliceProof.proof.pi_b[0][0]],
          [aliceProof.proof.pi_b[1][1], aliceProof.proof.pi_b[1][0]]
        ],
        pi_c: aliceProof.proof.pi_c.slice(0, 2)
      };
      aliceProof = {
        ...aliceFormatted,
        publicSignals: aliceProof.publicSignals
      };

      // Approve USDC spending
      await mockUSDC.connect(user).approve(hashVerifier.getAddress(), depositAmount);
      await mockUSDC.connect(user2).approve(hashVerifier.getAddress(), depositAmount);
    });

    it("Should allow depositing USDC", async function () {
      await expect(hashVerifier.connect(user).deposit(aliceUsernameHash, depositAmount))
        .to.emit(hashVerifier, "Deposited")
        .withArgs(aliceUsernameHash, depositAmount);

      expect(await hashVerifier.balances(aliceUsernameHash)).to.equal(depositAmount);
    });

    it("Should not allow depositing zero amount", async function () {
      await expect(
        hashVerifier.connect(user).deposit(aliceUsernameHash, 0)
      ).to.be.revertedWith("Amount must be greater than 0");
    });

    it("Should not allow depositing to zero username hash", async function () {
      await expect(
        hashVerifier.connect(user).deposit(0, depositAmount)
      ).to.be.revertedWith("Invalid username hash");
    });

    it("Should fail deposit if USDC transfer fails", async function () {
      // Remove approval
      await mockUSDC.connect(user).approve(hashVerifier.getAddress(), 0);
      
      await expect(
        hashVerifier.connect(user).deposit(aliceUsernameHash, depositAmount)
      ).to.be.reverted; // OpenZeppelin IERC20 uses custom errors
    });

    it("Should allow paying USDC between users", async function () {
      // First deposit
      await hashVerifier.connect(user).deposit(aliceUsernameHash, depositAmount);

      // Generate new proof for payment (need new nonce)
      const paymentProof = await generateProof(testUsername, testPassword, "9876543210");
      const paymentFormatted = {
        pi_a: paymentProof.proof.pi_a.slice(0, 2),
        pi_b: [
          [paymentProof.proof.pi_b[0][1], paymentProof.proof.pi_b[0][0]],
          [paymentProof.proof.pi_b[1][1], paymentProof.proof.pi_b[1][0]]
        ],
        pi_c: paymentProof.proof.pi_c.slice(0, 2)
      };

      // Then pay
      await expect(
        hashVerifier.connect(user).pay(
          paymentFormatted.pi_a,
          paymentFormatted.pi_b,
          paymentFormatted.pi_c,
          aliceUsernameHash,
          bobUsernameHash,
          paymentProof.publicSignals[1],
          paymentProof.publicSignals[2],
          payAmount
        )
      )
        .to.emit(hashVerifier, "Paid")
        .withArgs(aliceUsernameHash, bobUsernameHash, payAmount);

      expect(await hashVerifier.balances(aliceUsernameHash)).to.equal(depositAmount - payAmount);
      expect(await hashVerifier.balances(bobUsernameHash)).to.equal(payAmount);
    });

    it("Should not allow payment without sufficient balance", async function () {
      const paymentProof = await generateProof(testUsername, testPassword, "9876543210");
      const paymentFormatted = {
        pi_a: paymentProof.proof.pi_a.slice(0, 2),
        pi_b: [
          [paymentProof.proof.pi_b[0][1], paymentProof.proof.pi_b[0][0]],
          [paymentProof.proof.pi_b[1][1], paymentProof.proof.pi_b[1][0]]
        ],
        pi_c: paymentProof.proof.pi_c.slice(0, 2)
      };

      await expect(
        hashVerifier.connect(user).pay(
          paymentFormatted.pi_a,
          paymentFormatted.pi_b,
          paymentFormatted.pi_c,
          aliceUsernameHash,
          bobUsernameHash,
          paymentProof.publicSignals[1],
          paymentProof.publicSignals[2],
          payAmount
        )
      ).to.be.revertedWith("Insufficient balance");
    });

    it("Should not allow using the same nonce twice", async function () {
      // First deposit
      await hashVerifier.connect(user).deposit(aliceUsernameHash, depositAmount);

      // Generate payment proof
      const paymentProof = await generateProof(testUsername, testPassword, testNonce);
      const paymentFormatted = {
        pi_a: paymentProof.proof.pi_a.slice(0, 2),
        pi_b: [
          [paymentProof.proof.pi_b[0][1], paymentProof.proof.pi_b[0][0]],
          [paymentProof.proof.pi_b[1][1], paymentProof.proof.pi_b[1][0]]
        ],
        pi_c: paymentProof.proof.pi_c.slice(0, 2)
      };

      // First payment succeeds
      await hashVerifier.connect(user).pay(
        paymentFormatted.pi_a,
        paymentFormatted.pi_b,
        paymentFormatted.pi_c,
        aliceUsernameHash,
        bobUsernameHash,
        paymentProof.publicSignals[1],
        paymentProof.publicSignals[2],
        payAmount
      );

      // Second payment with same nonce fails
      await expect(
        hashVerifier.connect(user).pay(
          paymentFormatted.pi_a,
          paymentFormatted.pi_b,
          paymentFormatted.pi_c,
          aliceUsernameHash,
          bobUsernameHash,
          paymentProof.publicSignals[1],
          paymentProof.publicSignals[2],
          payAmount
        )
      ).to.be.revertedWith("Nonce already used");
    });
  });
}); 