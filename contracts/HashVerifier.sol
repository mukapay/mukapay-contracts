// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract HashVerifier {
    // Mapping to track used nonces for each username hash
    mapping(uint256 => mapping(uint256 => bool)) public usedNonces;
    
    // Mapping to store balances for each username hash
    mapping(uint256 => uint256) public balances;
    
    // The Verifier contract will be generated by snarkjs/circom
    IVerifier public verifier;
    
    // USDC token contract
    IERC20 public immutable usdc;
    
    event Deposited(uint256 indexed usernameHash, uint256 amount);
    event Paid(uint256 indexed fromUsernameHash, uint256 indexed toUsernameHash, uint256 amount);
    
    constructor(address _verifierAddress, address _usdcAddress) {
        verifier = IVerifier(_verifierAddress);
        usdc = IERC20(_usdcAddress);
    }
    
    // Verify ownership using ZK proof
    function verify(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256 usernameHash,
        uint256 nonce,
        uint256 resultHash
    ) internal returns (bool) {
        require(!usedNonces[usernameHash][nonce], "Nonce already used");
        
        // Verify the proof
        uint256[3] memory publicInputs;
        publicInputs[0] = usernameHash;
        publicInputs[1] = nonce;
        publicInputs[2] = resultHash;
        
        require(verifier.verifyProof(a, b, c, publicInputs), "Invalid proof");
        
        // Mark nonce as used
        usedNonces[usernameHash][nonce] = true;
        
        return true;
    }

    // Deposit USDC tokens to a username hash
    function deposit(
        uint256 usernameHash,
        uint256 amount
    ) external {
        require(amount > 0, "Amount must be greater than 0");
        require(usernameHash != 0, "Invalid username hash");
        
        // Transfer USDC from sender to contract
        require(usdc.transferFrom(msg.sender, address(this), amount), "Transfer failed");
        
        // Update balance
        balances[usernameHash] += amount;
        
        emit Deposited(usernameHash, amount);
    }

    // Pay USDC tokens from one username hash to another
    function pay(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256 fromUsernameHash,
        uint256 toUsernameHash,
        uint256 nonce,
        uint256 resultHash,
        uint256 amount
    ) external returns (bool) {
        // Verify ownership of the sending account
        require(verify(a, b, c, fromUsernameHash, nonce, resultHash), "Verification failed");
        
        // Check sufficient balance
        require(balances[fromUsernameHash] >= amount, "Insufficient balance");
        
        // Update balances
        balances[fromUsernameHash] -= amount;
        balances[toUsernameHash] += amount;
        
        emit Paid(fromUsernameHash, toUsernameHash, amount);
        return true;
    }
}

interface IVerifier {
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[3] memory input
    ) external view returns (bool);
} 